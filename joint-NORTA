#####################################################################
########################## Libraries ################################
#####################################################################

library(MASS) 
library(sdpt3r)

#####################################################################
##### Function to fix non-positive definite correlation matrix ######
#####################################################################
bisection_nearcorr <- function(Cz,Cx,tol){
 m <- dim(Cz)[1]
 C0 <- Cx #diag(m)
 ar=1
 al=0
 while(ar-al>tol){
   am=(ar+al)/2
   S= am*C0+(1-am)*Cz
   V=eigen(S)
   if(any(V$values<0)){
       al=am
   } else{
      ar=am}
 }
 return(ar*C0+(1-ar)*Cz)
}

CorrChol <- function(Cz,Cx,method){
 V=eigen(Cz)
 if(any(V$values<0)){
    if(method==1){
      C <- nearcorr(Cz)
      Cz <- C$X[[1]]}
     else{
    Cz <- bisection_nearcorr(Cz,Cx,1e-7)
    }
  }
 return(Cz)
}

#####################################################################
################# Norta Function for Task 1 #########################
#####################################################################

GN <- function(CovZ,Cx,MM,SS,list_dist,n,method){
   m <- dim(CovZ)[1]
   CovZ=CorrChol(CovZ,Cx,method)
   CholZ <- chol(CovZ)
   W <- mvrnorm(n, rep(0,m), diag(m))
   Z <- W%*%CholZ
   U <- pnorm(as.matrix(Z))
   X1 = sapply(1:m, FUN = function(i) list_dist[[i]](U[,i]))
   Corr=((t(X1)%*%X1)/n - MM)/SS
   diag(Corr)=1
   return(Corr)
}

#####################################################################
########## Stochastic Approximation Function for Task 1 #############
#####################################################################

RMapproach <- function(C0,Cx,MM,SS,list_dist,a,iter,tol,n,alph,method){
Cm <-C0
Ca <- C0
err <- 1:(iter+1)
er=GN(C0,Cx,MM,SS,list_dist,n,method)- Cx
err[1] <- norm(er,'F')
e <- err[1]
for(i in 1:iter){
    C1=C0-(a*i^(-alph))*er
    Cm=Cm+C1
    Cb=Cm/(i+1)
    er=GN(Cb,Cx,MM,SS,list_dist,n,method)-Cx
    err[i+1]<-norm(er,'F')
    ## Choosing the best correlation matrix
    if(err[i+1]<e){
      Ca <- Cb 
        e <- err[i+1]
    }
    if(norm(er,'F')<tol){
       print('Convergence was reached')
       print('Number of iterations:')
       print(i)
       err <- err[1:i+1]
       Cb=CorrChol(Cb,Cx,method)
       return(list(Cb,err))
    }
    C0=C1
}
print('All iterations was reached')
Ca=CorrChol(Ca,Cx,method)
return(list(Ca,err))
}

#################################################################
################## Example ######################################
#################################################################

#################################################################
############# Define correlation matrix of X ####################
#################################################################

L <- matrix(c(0.7, 0.7, 0.7,
              0.0, 0.0, 0.0,
              0.0, 0.0, 0.0,
              0.0, 0.0, 0.0,
              0.7, 0.7, 0.7, 
              0.0, 0.0, 0.0, 
              0.0, 0.0, 0.0,
              0.0, 0.0, 0.0, 
              0.7, 0.7, 0.7),9,3)

Phi <- matrix(c(1.0, 0.3, 0.3,
              0.3, 1.0, 0.3, 
              0.3, 0.3, 1.0),3,3)

Psi <- diag(9)
diag(Psi) <- 0.51

Sigm <- L%*%Phi%*%t(L) + Psi


Cx =  Sigm

m=dim(Cx)[1]

##########################################################################
### user can define the marginals and put the parameters in list_dist ####
##########################################################################

list_dist = list(function(L) qchisq(L,df=1), 
                 function(L) qt(L,df=5), 
                 function(L) qbinom(L,5,0.5), 
                 function(L) qbeta(L, shape1=1, shape2=5), 
                 function(L) qpois(L, lambda=7), 
                 function(L) qgamma(L, shape=3, rate=5),
                 function(L) qnorm(L,mean=0, sd=1), 
                 function(L) qunif(L,min=0, max=1), 
                 function(L) qbinom(L,1,0.3))

#################################################################
########## Put mean and standard deviation of list_dist #########
#################################################################
M= c(1, 
     0, 
     5*0.5, 
     1/(1+5), 
     7, 
     3/5,
     0, 
     0.5, 
     1*0.3)

S = c(sqrt(2), 
      sqrt(5/(5-2)), 
      sqrt(5*0.5*0.5), 
      sqrt(5/((1+5)^2*(1+5+1))), 
      sqrt(7), 
      sqrt(3/5^2),
      sqrt(1), 
      sqrt(1/12), 
      sqrt(1*0.7*0.3))

##################################################################
##################################################################

MM = M%*%t(M)
SS= S%*%t(S)

########################################################################
######## Choose the first Cz as Cx, i.e C0=Cx ##########################
########################################################################
C0=Cx

########################################################################
##### Define number of iterations, tolerance, a, number of sim n,    ###
##### and the method to compute the Nearest correlation Problem 1    ###
##### for nearcorr method and 2 for bisection method                 ###
########################################################################

iter=500
tol = 0.001
a=1
alph=0.75
n=100000
method=1

########################################################################
############## Compute Sigma_Z #########################################
########################################################################

start_time <- Sys.time()
L=RMapproach(C0,Cx,MM,SS,list_dist,a,iter,tol,n,alph,method)

end_time <- Sys.time()

end_time - start_time

########################################################
############## Norta method ############################
########################################################
Cz = L[[1]]
Cz
Cx_est=GN(Cz,Cx,MM,SS,list_dist,n,method)
Cx_est
##### Frobenius norm of the error #######
norm(Cx_est-Cx,'F')

########################################################
##############    Graphics convergence      ############
########################################################
Error <- L[[2]]
iterations <- 1:length(Error)
plot(iterations,Error, ylim=c(0,1))
lines(iterations,Error)
